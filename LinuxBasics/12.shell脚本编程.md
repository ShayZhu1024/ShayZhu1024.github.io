# shell脚本编程

## 1.脚本创建和执行

* 首行shebang机制,首行需要指明脚本执行的解释器, 例如`#!\bin\bash` 
* 注解使用#
* 标识符:数字 字母 下划线，开头不能是数字
* shebang下面 可以加上两行
    * set -u #未声明的变量不能引用
    * set -e #脚本发生错误，停止执行

### 不执行脚本只检查语法
bash -n script.sh

### 调试并执行
bash -x script.sh

### 执行脚本几种方式

bash script.sh

. script.sh  #在当前环境中执行

source script.sh #在当前环境中执行

chmod u+x script.sh
./script.sh


## 2.shell的变量

### 内置变量
    `PS1，PATH，UID，HOSTNAME，$$，BASHPID，PPID，$?，HISTSIZE SHLVL `

    $$ 和 BASHPID区别在于，在脚本中$$会显示最初的脚本BASH id， 不管是否是在子进程中打印$$,而BASHIP则是显示当前bash 进程id，注意这两个区别是在脚本中体现

    SHLVL shell的嵌套深度



### 用户自定义变量
```bash
变量=赋值  #即可完成变量定义，不要留有空格

作用范围，脚本执行的进程
```

### 注意： 
bash不支持浮点数

变量赋值是临时生效，当退出终端后，变量会自动删除，无法持久保存，脚本中的变量会随着脚
本结束，也会自动删除


### 环境变量
```bash
环境变量可以子进程中读到值，普通变量在子进程中无法读到值

export 变量

declare -x  变量

```

### 本地变量-局部变量
```bash
local 变量名字=值

这种变量只能在局部代码块有效， 通常在函数中

```

### 常量
```bash
readonly name
declare -r name

查看只读变量
readonly [-p]
declare -r

```

### 位置变量,在脚本中或者函数中存在
```bash
$1, $2, ... 对应第1个、第2个等参数，shift [n]换位置
$0 命令本身,包括路径
$* 传递给脚本的所有参数，全部参数合为一个字符串
$@ 传递给脚本的所有参数，每个参数为独立字符串
$# 传递给脚本的参数的个数
注意：$@ $* 只在被双引号包起来的时候才会有差异

```

### 变量的操作
```bash
普通操作下，默认bash中变量的值都是字符串
所以字符拼接：
X=${X}other-content
or
X+=other-content

通常对于变量引用，有一下方式
$VAR
${VAR} #这中方式可以方式名字和其他字符混淆
"${VAR}"  #这中方式可以防止字符分割同时可以保留VAR内容的原本格式

```


## 状态值

不同的命令执行之后，都会有一个状态值，保存在环境变量$?中，0表示成功，其他值表示失败，$?取值范例 0-255 

用户可以在脚本中使用以下命令自定义退出状态码

`exit N`

### 注意

* 脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字
* 如果exit后面无数字,终止退出状态取决于exit命令前面命令执行结果
* 如果没有exit命令, 即未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码


## 算数和逻辑运算

```bash
let var=算术表达式
((var=算术表达式)) 和上面等价
var=$[算术表达式]
var=$((算术表达式))

内建的随机数生成器变量：
$RANDOM   取值范围：0-32767

按位运算 & | ^ 
逻辑取反 ！
短路逻辑运算 && || 

```


## 条件测试

```bash
[ EXPRESSION ] 
[[ EXPRESSION ]] 相当于增强版的 [ ], 支持[]的用法,且支持扩展正则表达式和通配符，但是不支持 -o 条件或 -a 条件且
注意： EXPRESSION前后必须有空白字符

变量测试
    [ -v NAME ] 

数值测试
    -eq 是否等于
    -ne 是否不等于
    -gt 是否大于
    -ge 是否大于等于
    -lt 是否小于
    -le 是否小于等于

数值比较测试，也可以使用 ((  )), 在双括号里面可以使用C风格的条件测试
== 
!= 
<= 
>= 
< 
> 

字符串测试
        -z STRING 字符串是否为空，没定义或空为真，不空为假，
        -n STRING 字符串是否不空，不空为真，空为假 
        STRING   同上
        STRING1 = STRING2 是否等于，注意 = 前后有空格
        STRING1 != STRING2 是否不等于
        > ascii码是否大于ascii码
        < 是否小于

[[ ]] 字符串测试用法
    == 左侧字符串是否和右侧的PATTERN相同
    注意:此表达式用于[[ ]]中，PATTERN为通配符，通配符直接写，不需要“”和//
     =~ 左侧字符串是否能够被右侧的正则表达式的PATTERN所匹配
    注意: 此表达式用于[[ ]]中为扩展的正则表达式  正则直接写，不需要“”和//   如果不想表示元字符，而是符号本身可以使用""或者/转义

    注意字符串比较的时候，如果不需要分割的地方要用双引号，否则会字符串分割，如果需要分割的地方就不要用双引号


文件测试
    -e FILE: 文件存在性测试，存在为真，否则为假
    -b FILE：是否存在且为块设备文件
    -c FILE：是否存在且为字符设备文件
    -d FILE：是否存在且为目录文件
    -f FILE：是否存在且为普通文件
    -h FILE 或 -L FILE：存在且为符号链接文件
    -p FILE：是否存在且为命名管道文件
    -S FILE：是否存在且为套接字文件


文件权限测试：
    -r FILE：是否存在且可读
    -w FILE: 是否存在且可写
    -x FILE: 是否存在且可执行
    -u FILE：是否存在且拥有suid权限
    -g FILE：是否存在且拥有sgid权限
    -k FILE：是否存在且拥有sticky权限
    注意：最终结果由用户对文件的实际权限决定，而非文件属性决定


文件属性测试
    -s FILE #是否存在且非空
    -t fd #fd 文件描述符是否在某终端已经打开
    -N FILE #文件自从上一次被读取之后是否被修改过
    -O FILE #当前有效用户是否为文件属主
    -G FILE #当前有效用户是否为文件属组
    FILE1 -ef FILE2 #FILE1是否是FILE2的硬链接
    FILE1 -nt FILE2 #FILE1是否新于FILE2（mtime）
    FILE1 -ot FILE2 #FILE1是否旧于FILE2


组合测试条件
    [ EXPRESSION1 -a EXPRESSION2 ] #并且，EXPRESSION1和EXPRESSION2都是真，结果才为真
    [ EXPRESSION1 -o EXPRESSION2 ] #或者，EXPRESSION1和EXPRESSION2只要有一个真，结果就为真
    [ ! EXPRESSION ] #取反
    说明： -a 和 -o 需要使用测试命令进行，[[ ]] 不支持


```

## ()和{}命令批量执行

```bash
( list ) 会开启子shell,并且list中变量赋值及内部命令执行后,将不再影响后续的环境,但是可以读取到外部变量的值
{ list; } 不会启子shell, 在当前shell中运行,会影响当前shell环境
#(umask 066;touch f1.txt)
#( cd /data;ls )
```


## read 读取输入

```bash
-p "提示"
-r "禁止转移，原序列输出"
```

## bash shell 配置文件生效顺序

```bash
全局配置：针对所有用户皆有效
    /etc/profile
    /etc/profile.d/*.sh
    /etc/bashrc

个人配置：只针对特定用户有效
    ~/.bash_profile
    ~/.bashrc
```








