# 4.文件管理和IO重定向

<img src="../images/LinuxFHS1.png">

## 1.常用目录结构
```bash
/boot 引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录
/bin 所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序
/sbin 管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序
/etc 配置文件目录
/root 管理员的家目录
/home 普通用户家目录
/dev 设备文件存放在此
    b: block device，随机访问
    c: character device，线性访问
/usr 
    bin 就是/bin
    sbin 就是 /sbin
    lib 32位使用的库文件
    lib64 64位使用的库文件
    include  C程序的头文件(header files)
    share  结构化独立的数据，例如doc, man等
    local 自己本地安装的程序
        bin, sbin, lib, lib64, etc, share
/srv  统上运行的服务用到的数据
/lib 32为的库文件
/opt  第三方应用程序的安装位置
/lib64 64位的库文件
/mnt  临时文件系统挂载点    
/media 便携式设备挂载点
/run  软件运行起来产生的文件
/sys 用于输出当前系统上硬件设备相关信息虚拟文件系统，在内存中
/proc  用于输出内核与进程信息相关的虚拟文件系统,在内存中
/var variable data files
         cache: 应用程序缓存数据目录
        lib: 应用程序状态信息数据
        local：专用于为/usr/local下的应用程序存储可变数据
        lock: 锁文件
        log: 日志目录及文件
        opt: 专用于为/opt下的应用程序存储可变数据
        run: 运行中的进程相关数据,通常用于存储进程pid文件
        spool: 应用程序数据池
        tmp: 保存系统两次重启之间产生的临时数据
/tmp  临时文件存储位置
```


## 2. 常用文件分类位置
```bash
二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin
库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64
配置文件：/etc, /etc/DIRECTORY, /usr/local/etc
帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man, /usr/local/share/doc
```

## 3.Linux下的文件类型
* \- 普通文件
* d 目录文件directory
* l 符号链接文件link
* b 块设备block 
* c 字符设备character
* p 管道文件pipe
* s 套接字文件socket

## 4.通配符
通配符主要用来匹配文件名中的字符，不是用来匹配文本里面的字符

```bash
*  零个或任意多个字符
?  任意一个字符

[ang] 指定范围内的单个字符
[^ang] 取反
[:digit:]
[:alpha:]
[:upper:]
[:lower:]
[:alnum:]
[a-z] 表示的是a A b B c C d D这样的顺序，不是a，b，c，d这样的顺序

{} 花括号扩展
{1..3} 1,2,3
{001..004} 001,002,003,004
{10..1..2} 10 8 6 4 2
{1,4} 1 4
注意： 通配符是匹配，而{} 是扩展，两者有些区别

```

## 5.文本处理命令

```bash
stat  查看文件的详细属性信息

hexdump -C  win.txt   查看文本文件的二进制用16进制呈现 同时对照的有对应的字符

unix下和win下的文本转换
yum install -y dos2unix
dos2unix  
unix2dos

转换文件字符集编码
iconv

tr 字符串的转换功能非常强大,从标准输入读取数据，
tr [OPTION]... SET1 [SET2]
-d --delete：删除所有属于第一字符集的字符
-s --squeeze-repeats：把连续重复的字符以单独一个字符表示,即去重
-t 转换
set集合还支持转义字符 和通配符

tr -d "asdfa"  #如果串中含有asdfa其中任何一个字母 删除
tr -s "abc" #如果输入中含有abc任何一个重复出现压缩
tr -t "abc" "ABC"  #如果输入中含有abc 替换

tee 命令可以从标准输入读，然后将结果输出到标准输出上，同时还可以把结果输出到指定的文件中去

cat  
-A 这个选项常用，可以显示不可见字符
-n 显示编号
nl 显示行号，相当于cat -b 
tac 逆向显示文本内容
rev 一行的内容逆向显示
less 分页查看
head -n +2  显示前2
head -n -2  末尾两行不显示
tail -n -2
和
tail -n 2 结果是一样的，显示末尾两行
tail -n +2 从第2行开始显示
cut 按列抽取

      分割符  取出第几列1-3列和7列和9列 
cut -d " " -f1-3,7,9
paste 合并多个文件
-d  #分隔符：指定分隔符，默认用TAB，可以自己指定一个符号-d ""
-s  #所有行合成一行显示

seq 生成数字序列 
seq [option] <last|first last| first increment last>
-s 分隔符 默认是换行

wc 
	-l 行
	-w 单词
行数 单词数 字节数
sort
	-n 按照数字大小比较不是按照字符ascii比较
	-u 合并重复选项 去重
	-t c  c分隔符
	-k 3 按照c分割符的第三列排序
	-r 反序显示
	
	注意如果文本列显示如下：
	   23 sdfds
	   34    sdfdsfsdaf
	   45 dsafsdf
	   可以直接sort -nr  就行了
	
uniq 
	-c 显示每行重复次数
	-d 仅显示重复过的行
	-u 仅显示不重复的行
diff和patch
diff -u  file1 file2 #这种方式用来补丁文件
patch -b f1.txt f.patch
-b 用来补充前 备份f1.txt

cmp 查看二进制文件的不同
```

## 6. cp,mv.rm
```bash
cp 常用选项
cp -a  备份
cp -r 递归复制
cp -b 目标存在先备份
cp --backup=numbered 存在会按照数字多次备份

注意： 备份设备文件，需要加-a 
cp -a /dev/zero  ./zero.bak


mv  -b   存在先备份
mv -t 目标位置

批量修改文件名 rename
rename  [options] <expression> <replacement> <file>...
rename  <需要被替换的部分> <要被替换为的内容>  被替换的文件
rename  'txt' 'mp4' ./*    #把当前目录下的所有文件的txt后缀替换为mp4后缀

rm删除的文件，还可以被恢复，如果想使文件被删除之后，难以被恢复使用
shred 文件
shred 并不会把这个文件从磁盘上移除，而是会把这个文件内容完全撕碎，多次写入随机，从而达到无法修复的目的。


ln filename  hardLinkName
ln -s filename softLinkName
如果dir 是一个符号链接， 如果想删除这个符号链接
===rm -rf dir   ##记住，不要添加dir/  不要添加/ 否则删除不是链接文件而是链接对应的文件=== 
所以删除软连接本身的时候，可以不加上-r选项，防止出意外
rm  dir
```

|     源\目标      | 不存在                               | 存在且为文件 | 存在且为目录                           |
| :--------------: | ------------------------------------ | ------------ | -------------------------------------- |
|     一个文件     | 建立目标文件，并拷贝进去             | 覆盖 建议-i  | 会放在目录里，建立同名文件             |
|     多个文件     | 错误                                 | 错误         | 会放在目录中，建立同名文件             |
| 目录须使用-r选项 | 创建指定的目标文件夹，把文件拷贝进去 | 报错         | 在指定目录下创建同名目录，拷贝文件进去 |


## 7. 硬链接和软连接的区别总结

```bash
1. 本质：
硬链接：本质是同一个文件
软链接：本质不是同一个文件
2. 跨设备
硬链接：不支持
软链接：支持
3. inode
硬链接：相同
软链接：不同
4. 链接数
硬链接：创建新的硬链接,链接数会增加,删除硬链接,链接数减少
软链接：创建或删除,链接数不会变化
5. 文件夹
硬链接：不支持
软链接：支持
6. 相对路径
硬链接：原始文件相对路径是相对于当前工作目录
软链接：原始文件的相对路径是相对于链接文件的相对路径
7. 删除源文件
硬链接：只是链接数减一,但链接文件的访问不受影响
软链接：链接文件将无法访问
8. 文件类型
硬链接：和源文件相同
软链接：链接文件,和源文件无关
9. 文件大小
硬链接: 和源文件相同
软链接: 源文件的路径的长度
```

## 8. IO重定向

```bash
一个Linux程序，运行时候有三个基本的文件描述符 
0 1 2
这三个文件描述符分别是 标准输入  标准输出  标准错误
当然如果这个程序还打开了其他文件，还会有其他的文件描述符，标准输入当然可以重定向到其他文件，使得程序从标准输入读取的时候，可以读取这个被重定向的文件，但是程序也可以不从标准输入读取，直接打开其他文件读也是可以的。
但是标准输入可以让程序处理数据的来源非常灵活，如果一个程序遵守从标准输入读取数据，那么用户在使用这个程序的时候，通过重定向，管道，套接字，灵活的读取数据，换句话说：标准输入是操作系统提供的一个接口，一个规范，如果你实现这个规范，那么就可以和操作系统的其他特性和其他工具组合起来一起工作。同时标准输入默认也是和用户交互的一个通道

文件重定向的本质是：
	我们知道，一个命令在当前shell中执行，会创建一个新的进程环境，但是同时，他会继承父进程的	  资源和环境，这个环境和资源是只能读，不能改的，如果自己需要创建新的文件描述符，那么会在自	  己的进程空间创建，所以说我们执行ls ./ > text.log 这条命令的时候，ls会在自己的进程空	 间完成标准输出的重定向，命令结束，标准输出文件描述符执行的text.log就关闭了。所以如果我	们想持久重定向，就需要在当前shell进程空间来指定文件描述符所指向的文件，这样凡是在这个	 shell下执行的命令，这个重定向一直有效，实现方式 : exec CMD,
	exec 这个命令不会新开一个进程来执行CMD而是在当前进程空间执行CMD，这样相当于在当前		shell进程空间执行了这个CMD
	结束这个文件描述符的重定向，执行：exec 20>&-  其中20是你想结束的文件描述符
	

/dev/tty 这个设备指向当前的终端，所以如果你这样写
echo "hello world" > /dev/tty
那么"hello world"  一定会显示在用户终端上，即使标准输出被重定向或者整个脚本被重定向到其他文件

> 	标准输出重定向
1>	标准输出重定向
>>	标准输出重定向 追加
1>> 标准输出重定向 追加
2>  标准错误重定向
2>> 标准错误重定向 追加
&>  标准输出和标准错误重定向一个文件
&>>  标准错误和标准输出重定向一个文件 追加

0< 标准输入重定向
多行输入重定向 
cat <<EOF
this is a goood method
this is a good method
EOF


cmd <<< "xxxxxx"  表示把"xxxxx"作为标准输入传递给cmd命令
```

