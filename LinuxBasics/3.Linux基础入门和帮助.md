# 3.Linux基础入门和帮助


## 1.什么是shell
Shell 是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并
把它送入内核去执行，shell也被称为LINUX的命令解释器（command interpreter），Shell 本身是一个程序。将用户输入的命
令行拆解为”命令名“与”参数“。接着，根据命令名找到对应要执行的程序，对被执行的程序进行初始化，
然后将刚才解析出来的参数传给该程序并执行。shell是一种高级程序设计语言，提供了变量，函数，条件判断，循环等开发语言的功能
由于Shell本身是个程序，所以它可以被任何用户自己开发的各种Shell所代替

## 2.设置主机名

```bash
#暂时设置
hostname <name>

#永久性设置
hostname set-hostname <name>

* 主机名不支持下划线，但是支持横线，可以使用字母，横线或者数字组合
* 有些软件对主机名有特殊要求（否则可能导致软件无法正常启动）
* 一般按照组织的要求设置主机名，通常是有一定意义的
```

## 3.命令提示符 `$PS1` 变量
```bash
PS1='\[\e[1;32m\][\t \[\e[1;33m\]\u\[\e[35m\]@\h\[\e[1;31m\] \W\[\e[1;32m\]]\[\e[0m\]$'
其中： 
\u 当前用户
\h 表示主机名简称，即取主机名的第一个名字
\W 表示当前工作目录 
\$ 表示提示符(普通用户显示 $ root用户显示为#)
\H 表示完整的主机名
\w 表示完整的工作目录
\t 表示24小时的时间格式 时：分：秒
\T 表示12小时的时间格式 时：分：秒
\A 表示24小时时间格式 时：分
\! 表示命令历史数
\# 表示开机命令历史数
\d 表示日期，格式为星期 月 日
\v 表示Bash的版本信息

还可以给字体设置颜色等格式信息
“\e[F;B;Sm” 这个形式一般用在echo打印上，是没有问题的但是用在PS1变量要使用格式：“\[\e[F;B;Sm\]”

其中F字体颜色，B背景颜色，S显示样式，三个的顺序没有要求，可以缺省某个
前景色		背景色		颜色
30			40		黑色
31			41		红色
32			42		绿色
33			43		黄色
34			44		蓝色
35			45		紫色
36			46		青色
37			47		白色

“S” 为显示样式，常用的代码见下：
0  关闭颜色设置
1  粗体
4  加下划线
5  表示闪烁
7  表示前景色和背景色互换
8  表示隐藏

```

## 4.命令的执行过程、查看命令类型、查找命令、命令别名

```bash
1. 查看有没有命令别名  No
2. 查看是不是shell的内置命令 NO
3. 查看命令hash缓存有没有存在这个命令
    YES：根据这个缓存的地址去找命令文件，如果地址错误，报错，停止查找
    NO：接着往下
4. 通过$PATH 环境变量的路径中查找 存不存在这个命令 NO
5. 报错 COMMAND NOT FOUND


type COMMAND  #查看是内部命令还是外部命令
type -a COMMAND #查看所有这个命令的同名命令
help 可以查看内部命令列表
which -a | --skip-alias 
whereis          #都是可以查看外部命令的所在位置
hash 显示外部命令的hash缓存表
alias 别名=“命令.....”
unalias 别名
unalias -a  #取消所有别名

注意： 如果想永久别名生效需要把别名的配置写到配置文件中
* 仅对当前用户生效 ~/.bashrc
* 对所有用户生效 /etc/bashrc


**配置文件修改之后需要立即生效，如下两种方法：
.  配置文件
source 配置文件

其实这个. 和 source 是两个命令， 作用是在当前环境中执行后面的文件

别名和原名同名，如果不想使用命令别名，就想使用原命令，如下：
\ 命令
“命令”  参数....
'命令' 参数....
command 命令 参数....
/path/command 参数...  #仅对外部命令有效

多个命令批量执行
命令1；命令2；命令3

一个很长的命令如果一行写不下， 可以 \ 分成多行
注意：  \后面要立即换行，后面不能有空格

```

## 5.系统运行时候，加硬盘，并且让系统识别出来
```bash
echo '- - -' > /sys/class/scsi_host/host0/scan

如果有多个host,可以写一个循环

scanDisk() 
{
    for name in /sys/class/scsi_host/host*/scan; do
        echo '- - -' > $name
    done
}

```


